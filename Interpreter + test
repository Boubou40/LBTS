type taintness =
  | Tainted
  | Untainted

type ide = string 

type exp = 
  | CstInt of int 
  | CstTrue 
  | CstFalse 
  | Times of exp * exp
  | Sum of exp * exp
  | Sub of exp * exp
  | Eq of exp * exp
  | Iszero of exp
  | Or of exp * exp
  | And of exp * exp
  | Not of exp
  | Den of ide * taintness
  | Ifthenelse of exp * exp * exp
  | Let of ide * exp * exp
  | Fun of ide * exp * taintness 
  | Apply of exp * exp
  | Secret of exp
 
 

  type 'a env = (string * 'a) list

  type evT = Int of int * taintness
  | Bool of bool * taintness
  | Unbound
  | Funval of ide * exp * evT env * taintness (*contrôle de l'environnement*)
 



let bind env (x:string) (v:evT) = (x,v)::env;;


let rec lookup env x =
  match env with 
  | [] -> failwith ("not found")
  | (y, v)::r -> if x = y then v else lookup r x;;


type secure_env = 
  | TrustedEnv of evT env
  | UntrustedEnv of evT env

type trustBlock = {
  data: evT env;  (* Données sensibles protégées *)
  functions: (ide*exp*taintness) list;  (* Fonctions de confiance, y compris checkPassword *)
  handler: ide list;
  }
  
(* Fonction pour ajuster le taint *)
let add_taint v t =
  match v with
  | Int (i,_) -> Int (i, t)
  | Bool(b,_) -> Bool (b, t)
  | Funval (a,b,c,_) -> Funval (a,b,c,t)
  | Unbound -> failwith("Unbound value")


let get_taint v t =
  match v with
  | Int (_,t) -> t
  | Bool(_,t) -> t
  | Funval (_,_,_,t) -> t
  | Unbound -> failwith("Unbound value")


let typecheck (t, typeDescriptor) = 
  match t with 
  | "int" -> 
  (match typeDescriptor with
  | Int(u,_) -> true
  | _ -> false) 
  | "bool" ->
  (match typeDescriptor with 
  | Bool(u,_) -> true
  | _ -> false) 
  | _ -> failwith ("not a valid type");;



  (* Expression definition*)

let is_zero x = match (typecheck("int",x), x) with 
| (true, Int(y,Tainted)) -> Bool(y=0,Tainted) 
| (true, Int(y,Untainted)) -> Bool(y=0,Untainted)
| (_, _) -> failwith("run-time error");; 


let int_eq(x,y) = 
match (typecheck("int",x), typecheck("int",y), x, y) with 
| (true, true, Int(v,t1), Int(w,t2)) -> Bool(v = w, if t1 == Tainted || t2 == Tainted then Tainted else Untainted) 
| (_,_,_,_) -> failwith("run-time error ");; 

let int_plus(x, y) =
match(typecheck("int",x), typecheck("int",y), x, y) with 
| (true, true, Int(v,t1), Int(w,t2)) -> Int(v + w, if t1 == Tainted || t2 == Tainted then Tainted else Untainted) 
| (_,_,_,_) -> failwith("run-time error ");;

let int_sub(x, y) =
match(typecheck("int",x), typecheck("int",y), x, y) with 
| (true, true, Int(v,t1), Int(w,t2)) -> Int(v - w, if t1 == Tainted || t2 == Tainted then Tainted else Untainted) 
| (_,_,_,_) -> failwith("run-time error ");;


let int_times(x, y) =
match(typecheck("int",x), typecheck("int",y), x, y) with 
| (true, true, Int(v,t1), Int(w,t2)) -> Int(v * w, if t1 == Tainted || t2 == Tainted then Tainted else Untainted) 
| (_,_,_,_) -> failwith("run-time error ");;


let bool_and(b1,b2) = 
  match (typecheck("bool",b1), typecheck("bool",b2), b1, b2) with
  | (true, true, Bool(v1,t1), Bool(v2,t2)) -> Bool(v1 && v2,  if t1 == Tainted || t2 == Tainted then Tainted else Untainted)
  | (_,_,_,_) -> failwith("run-time error ");;

let bool_or(b1,b2) = 
  match (typecheck("bool",b1), typecheck("bool",b2), b1, b2) with
  | (true, true, Bool(v1,t1), Bool(v2,t2)) -> Bool(v1 || v2, if t1 == Tainted || t2 == Tainted then Tainted else Untainted)
  | (_,_,_,_) -> failwith("run-time error ");;

let bool_not b1 = 
  match (typecheck("bool",b1), b1) with
  | (true, Bool(true,t)) -> Bool(false,t)
  | (true, Bool(false,t)) -> Bool(true,t)
  | (_,_) -> failwith("run-time error ");;
   
  
let rec eval (e:exp) (env: evT env) = 
  match e with
  | Den (x,t) -> lookup env x
  | CstInt(n) -> Int(n,Untainted) 
  | CstTrue -> Bool(true,Untainted) 
  | CstFalse -> Bool(false,Untainted)
  | Iszero(e1) -> is_zero(eval e1 env)
  | Eq(e1, e2) -> int_eq((eval e1 env), (eval e2 env))
  | Times(e1,e2) -> int_times((eval e1 env), (eval e2 env))
  | Sum(e1, e2) -> int_plus ((eval e1 env), (eval e2 env))
  | Sub(e1, e2) -> int_sub ((eval e1 env), (eval e2 env))
  | And(e1, e2) -> bool_and((eval e1 env), (eval e2 env))
  | Or(e1, e2) -> bool_or ((eval e1 env), (eval e2 env))
  | Not(e1) -> bool_not(eval e1 env)

  | Ifthenelse(cond, e1, e2) ->
    let g = eval cond env in
    (match (typecheck("bool", g), g) with
    | (true, Bool(true, taint_status)) -> 
        let result = eval e1 env in
        (match result with
         | Int(value, _) -> Int(value, taint_status)
         | Bool(value, _) -> Bool(value, taint_status)
         | Funval(arg,ebody,env,_) -> Funval(arg,ebody,env,taint_status)
         | Unbound -> Unbound
         ) (* Ajouter d'autres cas au besoin *)

    | (true, Bool(false, taint_status)) -> 
        let result = eval e2 env in
        (match result with
         | Int(value, _) -> Int(value, taint_status)
         | Bool(value, _) -> Bool(value, taint_status)
         | Funval(arg,ebody,env,_) -> Funval(arg,ebody,env,taint_status)
         | Unbound -> Unbound       
        )
    | (_, _) -> failwith("nonboolean guard"));

  | Let(i, e, ebody) -> eval ebody (bind env i (eval e env))

  | Fun(arg, ebody, taint) -> Funval(arg,ebody,env,taint)  

  | Apply (f, arg) ->
      let vf = eval f env in
      let va = eval arg env in
      (match vf, va with
       | Funval (arg_name, body, fun_env, ft), (Int (_,at) | Bool (_,at)) ->
         let taint = if ft = Tainted || at = Tainted then Tainted else Untainted in
         let new_env = (arg_name, add_taint va taint) :: fun_env in
         add_taint (eval body new_env) taint
       | _ -> failwith("Type mismatch in application"))
  
       | _ -> _



         
      
  
      

let handle tb func_name arg env =
  if List.mem func_name tb.handler then
    (* Utilise List.find pour chercher la fonction dans la liste des fonctions *)
    try
      let (_, ebody, _) = List.find (fun (name, _, _) -> name = func_name) tb.functions in
      let arg_val = lookup env arg in
      let taint = get_taint arg_val in
      (match taint with
      | Untainted -> eval ebody ((arg,arg_val) :: tb.data)  (* Suppose que 'arg' et 'tb.env' sont correctement définis pour eval *)
      | Tainted -> failwith "Function is tainted and cannot be evaluated")
    
    with 
    | Not_found -> failwith "Function not found"
  else
    failwith "Function not available in handler"


    

